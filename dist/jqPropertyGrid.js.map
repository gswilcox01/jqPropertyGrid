{"version":3,"sources":["webpack:///jqPropertyGrid.js","webpack:///webpack/bootstrap ece46481cf12fc1941d1","webpack:///external \"jQuery\"","webpack:///./main.js","webpack:///./types/textarea.js"],"names":["jqPropertyGrid","modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","jQuery","$","getGroupHeaderRowHtml","displayName","getPropertyRowHtml","pgId","value","meta","postCreateInitFuncs","getValueFuncs","options","valueHTML","type","elemId","customType","customTypes","html","valueFunction","push","postCreateInitFunction","prop","Array","isArray","getSelectOptionHtml","val","fn","spinner","initSpinner","spectrum","initColorPicker","toHexString","description","helpIcon","useFontAwesome","showHelp","colspan2","id","selectedValue","length","text","opts","extend","change","onSpinnerChange","color","$spinner","this","min","max","pgIdSequence","obj","data","propertyRowsHTML","OTHER_GROUP_NAME","groupsHeaderRowHTML","browsable","currGroup","group","undefined","innerHTML","getValues","result","join","split"],"mappings":"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","file":"jqPropertyGrid.js","sourcesContent":["var jqPropertyGrid =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/dist/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 1);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports) {\n\nmodule.exports = jQuery;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(2);\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function($) {__webpack_require__(3);\n\nvar OTHER_GROUP_NAME = 'Other';\nvar GET_VALS_FUNC_KEY = 'pg.getValues';\nvar pgIdSequence = 0;\n\n/**\n * Generates the property grid\n * @param {object} obj - The object whose properties we want to display\n * @param {JQPropertyGridOptions} options - Options object for the component\n */\n\nconsole.log('here!');\n$.fn.jqPropertyGrid = function (obj, options) {\n\t// Check if the user called the 'get' function (to get the values back from the grid).\n\tif (typeof obj === 'string' && obj === 'get') {\n\t\tif (typeof this.data(GET_VALS_FUNC_KEY) === 'function') {\n\t\t\treturn this.data(GET_VALS_FUNC_KEY)();\n\t\t}\n\n\t\treturn null;\n\t} else if (typeof obj !== 'object' || obj === null) {\n\t\tconsole.error('jqPropertyGrid 1st parameter must be a JS data object to initialize the grid.');\n\t\treturn;\n\t} else if (typeof options !== 'object' || options === null) {\n\t\tconsole.error('jqPropertyGrid 2nd parameter must be a JS object defining the grid display options.');\n\t\treturn;\n\t}\n\n\t// Normalize options\n\toptions.customTypes = options.customTypes || {};\n\tvar meta = options.meta;\n\n\t// Add our first external \"type\"\n\t// TODO: move all types to external types\n\t// TODO: use webpack function read all files in \"types\" directory, and auto-add by filename\n\toptions.customTypes['textarea'] = __webpack_require__(4);\n\n\t// Seems like we are ok to create the grid\n\tvar propertyRowsHTML = { OTHER_GROUP_NAME: '' };\n\tvar groupsHeaderRowHTML = {};\n\tvar postCreateInitFuncs = [];\n\tvar getValueFuncs = {};\n\tvar pgId = 'pg' + pgIdSequence++;\n\n\t// LOOP through all properties in the DATA OBJECT\n\tfor (var prop in obj) {\n\t\t// Skip if this is not a direct property, a function, or its meta says it's non browsable\n\t\tif (!obj.hasOwnProperty(prop) || typeof obj[prop] === 'function' || meta[prop] && meta[prop].browsable === false) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// If this is the first time we run into this group create the group row\n\t\tvar currGroup = meta[prop] && meta[prop].group || OTHER_GROUP_NAME;\n\t\tif (groupsHeaderRowHTML[currGroup] === undefined) {\n\t\t\tgroupsHeaderRowHTML[currGroup] = getGroupHeaderRowHtml(currGroup);\n\t\t\tpropertyRowsHTML[currGroup] = '';\n\t\t}\n\n\t\t// Append the current cell html into the group html\n\t\tpropertyRowsHTML[currGroup] += getPropertyRowHtml(pgId, prop, obj[prop], meta[prop], postCreateInitFuncs, getValueFuncs, options);\n\t}\n\n\t// Now we have all the html we need, just assemble it\n\tvar innerHTML = '<table class=\"pgTable\">';\n\tfor (var group in groupsHeaderRowHTML) {\n\t\t// Skip the \"Other\" group, it always comes last\n\t\tif (group == OTHER_GROUP_NAME) continue;\n\n\t\tinnerHTML += groupsHeaderRowHTML[group];\n\t\tinnerHTML += propertyRowsHTML[group];\n\t}\n\n\t// Finally add the \"Other\" group to the end\n\tif (propertyRowsHTML[OTHER_GROUP_NAME]) {\n\t\tinnerHTML += groupsHeaderRowHTML[OTHER_GROUP_NAME];\n\t\tinnerHTML += propertyRowsHTML[OTHER_GROUP_NAME];\n\t}\n\n\t// Close the table and apply it to the div\n\tinnerHTML += '</table>';\n\tthis.html(innerHTML);\n\n\t// Now that HTML is in the DOM, run any post-init functions\n\tfor (var i = 0; i < postCreateInitFuncs.length; ++i) {\n\t\tif (typeof postCreateInitFuncs[i] === 'function') {\n\t\t\tpostCreateInitFuncs[i]();\n\t\t}\n\t}\n\n\t// Create a function that will return the values back from the property grid\n\tvar getValues = function () {\n\t\tvar result = {};\n\t\tfor (var prop in getValueFuncs) {\n\t\t\tif (typeof getValueFuncs[prop] !== 'function') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tresult[prop] = getValueFuncs[prop]();\n\t\t}\n\n\t\treturn result;\n\t};\n\n\tthis.data(GET_VALS_FUNC_KEY, getValues);\n};\n\n/**\n * Gets the html of a group header row\n * @param {string} displayName - The group display name\n */\nfunction getGroupHeaderRowHtml(displayName) {\n\treturn '<tr class=\"pgGroupRow\"><td colspan=\"2\" class=\"pgGroupCell\">' + displayName + '</td></tr>';\n}\n\n/**\n * Gets the html of a specific property row\n * @param {string} pgId - The property-grid id being rendered\n * @param {string} name - The property name\n * @param {*} value - The current property value\n * @param {object} meta - A metadata object describing this property\n * @param {function[]} [postCreateInitFuncs] - An array to fill with functions to run after the grid was created\n * @param {object.<string, function>} [getValueFuncs] - A dictionary where the key is the property name and the value is a function to retrieve the property selected value\n * @param {object} options - The global options object\n */\nfunction getPropertyRowHtml(pgId, name, value, meta, postCreateInitFuncs, getValueFuncs, options) {\n\tmeta = meta || {};\n\tvar displayName = meta.name || name;\n\tvar type = meta.type || '';\n\tvar elemId = pgId + name;\n\tvar valueHTML;\n\n\t// check if type is registered in customTypes\n\tvar customType = options.customTypes[type];\n\tif (customType) {\n\t\tvalueHTML = customType.html(elemId, name, value, meta);\n\t\tgetValueFuncs[name] = customType.valueFunction(elemId, name, value, meta);\n\t\tif (customType.hasOwnProperty('postCreateInitFunction')) {\n\t\t\tpostCreateInitFuncs.push(customType.postCreateInitFunction(elemId, name, value, meta));\n\t\t}\n\t}\n\n\t// If boolean create checkbox\n\telse if (type === 'boolean' || type === '' && typeof value === 'boolean') {\n\t\t\tvalueHTML = '<input type=\"checkbox\" id=\"' + elemId + '\" value=\"' + name + '\"' + (value ? ' checked' : '') + ' />';\n\t\t\tgetValueFuncs[name] = function () {\n\t\t\t\treturn $('#' + elemId).prop('checked');\n\t\t\t};\n\t\t}\n\n\t\t// If options create drop-down list\n\t\telse if (type === 'options' && Array.isArray(meta.options)) {\n\t\t\t\tvalueHTML = getSelectOptionHtml(elemId, value, meta.options);\n\t\t\t\tgetValueFuncs[name] = function () {\n\t\t\t\t\treturn $('#' + elemId).val();\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// If number and a jqueryUI spinner is loaded use it\n\t\t\telse if (typeof $.fn.spinner === 'function' && (type === 'number' || type === '' && typeof value === 'number')) {\n\t\t\t\t\tvalueHTML = '<input type=\"text\" id=\"' + elemId + '\" value=\"' + value + '\" style=\"width:50px\" />';\n\t\t\t\t\tpostCreateInitFuncs.push(initSpinner(elemId, meta.options));\n\t\t\t\t\tgetValueFuncs[name] = function () {\n\t\t\t\t\t\treturn $('#' + elemId).spinner('value');\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\t// If color and we have the spectrum color picker use it\n\t\t\t\telse if (type === 'color' && typeof $.fn.spectrum === 'function') {\n\t\t\t\t\t\tvalueHTML = '<input type=\"text\" id=\"' + elemId + '\" />';\n\t\t\t\t\t\tpostCreateInitFuncs.push(initColorPicker(elemId, value, meta.options));\n\t\t\t\t\t\tgetValueFuncs[name] = function () {\n\t\t\t\t\t\t\treturn $('#' + elemId).spectrum('get').toHexString();\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\t// If label (for read-only)\n\t\t\t\t\telse if (type === 'label') {\n\t\t\t\t\t\t\tif (typeof meta.description === 'string' && meta.description) {\n\t\t\t\t\t\t\t\tvalueHTML = '<label for=\"' + elemId + '\" title=\"' + meta.description + '\">' + value + '</label>';\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tvalueHTML = '<label for=\"' + elemId + '\">' + value + '</label>';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tgetValueFuncs[name] = function () {\n\t\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Default is textbox\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tvalueHTML = '<input type=\"text\" id=\"' + elemId + '\" value=\"' + value + '\"</input>';\n\t\t\t\t\t\t\t\tgetValueFuncs[name] = function () {\n\t\t\t\t\t\t\t\t\treturn $('#' + elemId).val();\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t}\n\n\t// Now create the label HTML for column 1\n\tvar helpIcon = '[?]';\n\tif (options.useFontAwesome) {\n\t\thelpIcon = '<i class=\"fa fa-question-circle-o\"></i>';\n\t}\n\tif (typeof meta.description === 'string' && meta.description && (typeof meta.showHelp === 'undefined' || meta.showHelp)) {\n\t\tdisplayName += '<span class=\"pgTooltip\" title=\"' + meta.description + '\">' + helpIcon + '</span>';\n\t}\n\n\t// Now create the TR which has 1 column for the label and 1 column for the INPUT\n\tif (meta.colspan2) {\n\t\treturn '<tr class=\"pgRow\"><td colspan=\"2\" class=\"pgCell\">' + valueHTML + '</td></tr>';\n\t} else {\n\t\treturn '<tr class=\"pgRow\"><td class=\"pgCell\">' + displayName + '</td><td class=\"pgCell\">' + valueHTML + '</td></tr>';\n\t}\n}\n\n/**\n * Gets a select-option (dropdown) html\n * @param {string} id - The select element id\n * @param {string} [selectedValue] - The current selected value\n * @param {*[]} options - An array of option. An element can be an object with value/text pairs, or just a string which is both the value and text\n * @returns {string} The select element html\n */\nfunction getSelectOptionHtml(id, selectedValue, options) {\n\tselectedValue = selectedValue || '';\n\toptions = options || [];\n\n\tvar html = '<select id=\"' + id + '\">';\n\tfor (var i = 0; i < options.length; i++) {\n\t\tvar value = typeof options[i] === 'object' ? options[i].value : options[i];\n\t\tvar text = typeof options[i] === 'object' ? options[i].text : options[i];\n\n\t\thtml += '<option value=\"' + value + '\"';\n\t\thtml += selectedValue === value ? ' selected>' : '>';\n\t\thtml += text + '</option>';\n\t}\n\thtml += '</select>';\n\treturn html;\n}\n\n/**\n * Gets an init function to a number textbox\n * @param {string} id - The number textbox id\n * @param {object} [options] - The spinner options\n * @returns {function}\n */\nfunction initSpinner(id, options) {\n\t// Copy the options so we won't change the user \"copy\"\n\tvar opts = $.extend({}, options);\n\n\t// Add a handler to the change event to verify the min/max (only if not provided by the user)\n\topts.change = typeof opts.change === 'undefined' ? onSpinnerChange : opts.change;\n\n\treturn function onSpinnerInit() {\n\t\t$('#' + id).spinner(opts);\n\t};\n}\n\n/**\n * Gets an init function to a color textbox\n * @param {string} id - The color textbox id\n * @param {string} [color] - The current color (e.g #000000)\n * @param {object} [options] - The color picker options\n * @returns {function}\n */\nfunction initColorPicker(id, color, options) {\n\tvar opts = $.extend({}, options);\n\tif (typeof color === 'string') {\n\t\topts.color = color;\n\t}\n\n\treturn function onColorPickerInit() {\n\t\t$('#' + id).spectrum(opts);\n\t};\n}\n\n/**\n * Handler for the spinner change event\n */\nfunction onSpinnerChange() {\n\tvar $spinner = $(this);\n\tvar value = $spinner.spinner('value');\n\n\t// If the value is null and the real value in the textbox is string we empty the textbox\n\tif (value === null && typeof $spinner.val() === 'string') {\n\t\t$spinner.val('');\n\t\treturn;\n\t}\n\n\t// Now check that the number is in the min/max range.\n\tvar min = $spinner.spinner('option', 'min');\n\tvar max = $spinner.spinner('option', 'max');\n\tif (typeof min === 'number' && this.value < min) {\n\t\tthis.value = min;\n\t\treturn;\n\t}\n\n\tif (typeof max === 'number' && this.value > max) {\n\t\tthis.value = max;\n\t}\n}\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports) {\n\n// removed by extract-text-webpack-plugin\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function($) {module.exports = {\n  html: function (elemId, name, value, meta) {\n    var html = '<textarea id=\"' + elemId + '\" rows=6 style=\"white-space: nowrap; overflow-x: auto; width:100%\">';\n    if (value instanceof Array) {\n      html += value.join(\"\\n\");\n    }\n    html += '</textarea>';\n    return html;\n  },\n  valueFunction: function (elemId, name, value, meta) {\n    return function () {\n      return $('#' + elemId).val().split('\\n');\n    };\n  }\n};\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// jqPropertyGrid.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/dist/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap ece46481cf12fc1941d1","module.exports = jQuery;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"jQuery\"\n// module id = 0\n// module chunks = 0","require('./main.css')\n\nvar OTHER_GROUP_NAME = 'Other';\nvar GET_VALS_FUNC_KEY = 'pg.getValues';\nvar pgIdSequence = 0;\n\n/**\n * Generates the property grid\n * @param {object} obj - The object whose properties we want to display\n * @param {JQPropertyGridOptions} options - Options object for the component\n */\n\nconsole.log('here!')\n$.fn.jqPropertyGrid = function(obj, options) {\n\t// Check if the user called the 'get' function (to get the values back from the grid).\n\tif (typeof obj === 'string' && obj === 'get') {\n\t\tif (typeof this.data(GET_VALS_FUNC_KEY) === 'function') {\n\t\t\treturn this.data(GET_VALS_FUNC_KEY)();\n\t\t}\n\n\t\treturn null;\n\t} else if (typeof obj !== 'object' || obj === null) {\n\t\tconsole.error('jqPropertyGrid 1st parameter must be a JS data object to initialize the grid.');\n\t\treturn;\n\t} else if (typeof options !== 'object' || options === null) {\n\t\tconsole.error('jqPropertyGrid 2nd parameter must be a JS object defining the grid display options.');\n\t\treturn;\n\t}\n\n\t// Normalize options\n\toptions.customTypes = options.customTypes || {};\n\tvar meta = options.meta;\n\n\t// Add our first external \"type\"\n\t// TODO: move all types to external types\n\t// TODO: use webpack function read all files in \"types\" directory, and auto-add by filename\n\toptions.customTypes['textarea'] = require('./types/textarea.js')\n\n\t// Seems like we are ok to create the grid\n\tvar propertyRowsHTML = {OTHER_GROUP_NAME: ''};\n\tvar groupsHeaderRowHTML = {};\n\tvar postCreateInitFuncs = [];\n\tvar getValueFuncs = {};\n\tvar pgId = 'pg' + (pgIdSequence++);\n\n\t// LOOP through all properties in the DATA OBJECT\n\tfor (var prop in obj) {\n\t\t// Skip if this is not a direct property, a function, or its meta says it's non browsable\n\t\tif (!obj.hasOwnProperty(prop) || typeof obj[prop] === 'function' || (meta[prop] && meta[prop].browsable === false)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// If this is the first time we run into this group create the group row\n\t\tvar currGroup = (meta[prop] && meta[prop].group) || OTHER_GROUP_NAME;\n\t\tif (groupsHeaderRowHTML[currGroup] === undefined) {\n\t\t\tgroupsHeaderRowHTML[currGroup] = getGroupHeaderRowHtml(currGroup);\n\t\t\tpropertyRowsHTML[currGroup] = '';\n\t\t}\n\n\t\t// Append the current cell html into the group html\n\t\tpropertyRowsHTML[currGroup] += getPropertyRowHtml(pgId, prop, obj[prop], meta[prop], postCreateInitFuncs, getValueFuncs, options);\n\t}\n\n\t// Now we have all the html we need, just assemble it\n\tvar innerHTML = '<table class=\"pgTable\">';\n\tfor (var group in groupsHeaderRowHTML) {\n\t\t// Skip the \"Other\" group, it always comes last\n\t\tif (group == OTHER_GROUP_NAME) continue;\n\n\t\tinnerHTML += groupsHeaderRowHTML[group];\n\t\tinnerHTML += propertyRowsHTML[group];\n\t}\n\n\t// Finally add the \"Other\" group to the end\n\tif (propertyRowsHTML[OTHER_GROUP_NAME]) {\n\t\tinnerHTML += groupsHeaderRowHTML[OTHER_GROUP_NAME];\n\t\tinnerHTML += propertyRowsHTML[OTHER_GROUP_NAME];\n\t}\n\n\t// Close the table and apply it to the div\n\tinnerHTML += '</table>';\n\tthis.html(innerHTML);\n\n\t// Now that HTML is in the DOM, run any post-init functions\n\tfor (var i = 0; i < postCreateInitFuncs.length; ++i) {\n\t\tif (typeof postCreateInitFuncs[i] === 'function') {\n\t\t\tpostCreateInitFuncs[i]();\n\t\t}\n\t}\n\n\t// Create a function that will return the values back from the property grid\n\tvar getValues = function() {\n\t\tvar result = {};\n\t\tfor (var prop in getValueFuncs) {\n\t\t\tif (typeof getValueFuncs[prop] !== 'function') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tresult[prop] = getValueFuncs[prop]();\n\t\t}\n\n\t\treturn result;\n\t};\n\n\tthis.data(GET_VALS_FUNC_KEY, getValues);\n};\n\n/**\n * Gets the html of a group header row\n * @param {string} displayName - The group display name\n */\nfunction getGroupHeaderRowHtml(displayName) {\n\treturn '<tr class=\"pgGroupRow\"><td colspan=\"2\" class=\"pgGroupCell\">' + displayName + '</td></tr>';\n}\n\n/**\n * Gets the html of a specific property row\n * @param {string} pgId - The property-grid id being rendered\n * @param {string} name - The property name\n * @param {*} value - The current property value\n * @param {object} meta - A metadata object describing this property\n * @param {function[]} [postCreateInitFuncs] - An array to fill with functions to run after the grid was created\n * @param {object.<string, function>} [getValueFuncs] - A dictionary where the key is the property name and the value is a function to retrieve the property selected value\n * @param {object} options - The global options object\n */\nfunction getPropertyRowHtml(pgId, name, value, meta, postCreateInitFuncs, getValueFuncs, options) {\n\tmeta = meta || {};\n\tvar displayName = meta.name || name;\n\tvar type = meta.type || '';\n\tvar elemId = pgId + name;\n\tvar valueHTML;\n\n\t// check if type is registered in customTypes\n\tvar customType = options.customTypes[type]\n\tif (customType) {\n\t\tvalueHTML = customType.html(elemId, name, value, meta);\n\t\tgetValueFuncs[name] = customType.valueFunction(elemId, name, value, meta);\n\t\tif (customType.hasOwnProperty('postCreateInitFunction')) {\n\t\t\tpostCreateInitFuncs.push(customType.postCreateInitFunction(elemId, name, value, meta));\n\t\t}\n\t}\n\n\t// If boolean create checkbox\n\telse if (type === 'boolean' || (type === '' && typeof value === 'boolean')) {\n\t\tvalueHTML = '<input type=\"checkbox\" id=\"' + elemId + '\" value=\"' + name + '\"' + (value ? ' checked' : '') + ' />';\n\t\tgetValueFuncs[name] = function() {\n\t\t\treturn $('#' + elemId).prop('checked');\n\t\t};\n\t}\n\n\t// If options create drop-down list\n\telse if (type === 'options' && Array.isArray(meta.options)) {\n\t\tvalueHTML = getSelectOptionHtml(elemId, value, meta.options);\n\t\tgetValueFuncs[name] = function() {\n\t\t\treturn $('#' + elemId).val();\n\t\t};\n\t}\n\n\t// If number and a jqueryUI spinner is loaded use it\n\telse if (typeof $.fn.spinner === 'function' && (type === 'number' || (type === '' && typeof value === 'number'))) {\n\t\tvalueHTML = '<input type=\"text\" id=\"' + elemId + '\" value=\"' + value + '\" style=\"width:50px\" />';\n\t\tpostCreateInitFuncs.push(initSpinner(elemId, meta.options));\n\t\tgetValueFuncs[name] = function() {\n\t\t\treturn $('#' + elemId).spinner('value');\n\t\t};\n\t}\n\n\t// If color and we have the spectrum color picker use it\n\telse if (type === 'color' && typeof $.fn.spectrum === 'function') {\n\t\tvalueHTML = '<input type=\"text\" id=\"' + elemId + '\" />';\n\t\tpostCreateInitFuncs.push(initColorPicker(elemId, value, meta.options));\n\t\tgetValueFuncs[name] = function() {\n\t\t\treturn $('#' + elemId).spectrum('get').toHexString();\n\t\t};\n\t}\n\n\t// If label (for read-only)\n\telse if (type === 'label') {\n\t\tif (typeof meta.description === 'string' && meta.description) {\n\t\t\tvalueHTML = '<label for=\"' + elemId + '\" title=\"' + meta.description + '\">' + value + '</label>';\n\t\t} else {\n\t\t\tvalueHTML = '<label for=\"' + elemId + '\">' + value + '</label>';\n\t\t}\n\t\tgetValueFuncs[name] = function() {\n\t\t\treturn value;\n\t\t};\n\t}\n\n\t// Default is textbox\n\telse {\n\t\tvalueHTML = '<input type=\"text\" id=\"' + elemId + '\" value=\"' + value + '\"</input>';\n\t\tgetValueFuncs[name] = function() {\n\t\t\treturn $('#' + elemId).val();\n\t\t};\n\t}\n\n\t// Now create the label HTML for column 1\n\tvar helpIcon = '[?]';\n\tif (options.useFontAwesome) {\n\t\thelpIcon = '<i class=\"fa fa-question-circle-o\"></i>';\n\t}\n\tif (typeof meta.description === 'string' && meta.description &&\n\t\t(typeof meta.showHelp === 'undefined' || meta.showHelp)) {\n\t\tdisplayName += '<span class=\"pgTooltip\" title=\"' + meta.description + '\">' + helpIcon + '</span>';\n\t}\n\n\t// Now create the TR which has 1 column for the label and 1 column for the INPUT\n\tif (meta.colspan2) {\n\t\treturn '<tr class=\"pgRow\"><td colspan=\"2\" class=\"pgCell\">' + valueHTML + '</td></tr>';\n\t} else {\n\t\treturn '<tr class=\"pgRow\"><td class=\"pgCell\">' + displayName + '</td><td class=\"pgCell\">' + valueHTML + '</td></tr>';\n\t}\n}\n\n/**\n * Gets a select-option (dropdown) html\n * @param {string} id - The select element id\n * @param {string} [selectedValue] - The current selected value\n * @param {*[]} options - An array of option. An element can be an object with value/text pairs, or just a string which is both the value and text\n * @returns {string} The select element html\n */\nfunction getSelectOptionHtml(id, selectedValue, options) {\n\tselectedValue = selectedValue || '';\n\toptions = options || [];\n\n\tvar html = '<select id=\"' + id + '\">';\n\tfor (var i = 0; i < options.length; i++) {\n\t\tvar value = typeof options[i] === 'object' ? options[i].value : options[i];\n\t\tvar text = typeof options[i] === 'object' ? options[i].text : options[i];\n\n\t\thtml += '<option value=\"' + value + '\"';\n\t\thtml += (selectedValue === value) ? ' selected>' : '>';\n\t\thtml += text + '</option>';\n\t}\n\thtml += '</select>';\n\treturn html;\n}\n\n/**\n * Gets an init function to a number textbox\n * @param {string} id - The number textbox id\n * @param {object} [options] - The spinner options\n * @returns {function}\n */\nfunction initSpinner(id, options) {\n\t// Copy the options so we won't change the user \"copy\"\n\tvar opts = $.extend({}, options);\n\n\t// Add a handler to the change event to verify the min/max (only if not provided by the user)\n\topts.change = typeof opts.change === 'undefined' ? onSpinnerChange : opts.change;\n\n\treturn function onSpinnerInit() {\n\t\t$('#' + id).spinner(opts);\n\t};\n}\n\n/**\n * Gets an init function to a color textbox\n * @param {string} id - The color textbox id\n * @param {string} [color] - The current color (e.g #000000)\n * @param {object} [options] - The color picker options\n * @returns {function}\n */\nfunction initColorPicker(id, color, options) {\n\tvar opts = $.extend({}, options);\n\tif (typeof color === 'string') {\n\t\topts.color = color;\n\t}\n\n\treturn function onColorPickerInit() {\n\t\t$('#' + id).spectrum(opts);\n\t};\n}\n\n/**\n * Handler for the spinner change event\n */\nfunction onSpinnerChange() {\n\tvar $spinner = $(this);\n\tvar value = $spinner.spinner('value');\n\n\t// If the value is null and the real value in the textbox is string we empty the textbox\n\tif (value === null && typeof $spinner.val() === 'string') {\n\t\t$spinner.val('');\n\t\treturn;\n\t}\n\n\t// Now check that the number is in the min/max range.\n\tvar min = $spinner.spinner('option', 'min');\n\tvar max = $spinner.spinner('option', 'max');\n\tif (typeof min === 'number' && this.value < min) {\n\t\tthis.value = min;\n\t\treturn;\n\t}\n\n\tif (typeof max === 'number' && this.value > max) {\n\t\tthis.value = max;\n\t}\n}\n\n\n\n// WEBPACK FOOTER //\n// ./main.js","module.exports = {\n  html: function (elemId, name, value, meta) {\n    var html = '<textarea id=\"' + elemId + '\" rows=6 style=\"white-space: nowrap; overflow-x: auto; width:100%\">';\n    if (value instanceof Array) {\n      html += value.join(\"\\n\");\n    }\n    html += '</textarea>';\n    return html;\n  },\n  valueFunction: function (elemId, name, value, meta) {\n    return function () {\n      return $('#' + elemId).val().split('\\n');\n    }\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ./types/textarea.js"],"sourceRoot":""}